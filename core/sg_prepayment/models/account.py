# -*- coding: utf-8 -*-
import time
from datetime import datetime
from dateutil.relativedelta import relativedelta
from odoo import api, fields, models, _
from odoo.exceptions import UserError, ValidationError
from odoo.addons import decimal_precision as dp

class account_model(models.Model):
    _name = "account.model"
    _inherit = ['mail.thread']
    _description = "Account Model"

    name = fields.Char('Model Name', help="This is a model for recurring accounting entries", track_visibility='onchange')
    journal_id = fields.Many2one('account.journal', 'Journal')
    company_id = fields.Many2one('res.company',related='journal_id.company_id', string='Company', store=True)
    lines_id = fields.One2many('account.model.line', 'model_id', string='Model Entries', copy=True)
    legend = fields.Text(string='Legend', size=100, default=lambda self: _('You can specify year, month and date in the name of the model using the following labels:\n\n%(year)s: To Specify Year \n%(month)s: To Specify Month \n%(date)s: Current Date\n\ne.g. My model on %(date)s'))

    @api.multi
    def generate(self,data=None):
        if data is None:
            data = {}
        ctx = self._context if self._context else {}
        move_ids = []
        entry = {}
        account_move_obj = self.env['account.move']
        account_move_line_obj = self.env['account.move.line']
        pt_obj = self.env['account.payment.term']

        context = dict(ctx or {})

        move_date = context.get('date', time.strftime('%Y-%m-%d'))
        move_date = datetime.strptime(move_date,"%Y-%m-%d")
        for model in self:
            try:
                entry['name'] = model.name%{'year': move_date.strftime('%Y'), 'month': move_date.strftime('%m'), 'date': move_date.strftime('%Y-%m')}
            except:
                raise ValidationError(_('Wrong Model!\n You have a wrong expression %(...)s in your model!'))
            move_id = account_move_obj.create({
                'ref': entry['name'],
                'journal_id': model.journal_id.id,
                'company_id': model.company_id.id,
                'date': context.get('date', fields.Date.context_today(self))
            })
            move_ids.append(move_id.id)
            for line in model.lines_id:
                analytic_account_id = False
                if line.analytic_account_id:
                    if not model.journal_id.analytic_journal_id:
                        raise ValidationError(_('No Analytic Journal!\n You have to define an analytic journal on the '+ str(model.journal_id.name)+' journal!'))
                    analytic_account_id = line.analytic_account_id.id
                vals = {
                    'move_id': move_id.id,
                    'journal_id': model.journal_id.id,
                    'company_id': model.company_id.id,
                    'analytic_account_id': analytic_account_id
                }

                date_maturity = context.get('date',time.strftime('%Y-%m-%d'))
                if line.date_maturity == 'partner':
                    if not line.partner_id:
                        raise ValidationError(_('Error!\n Maturity date of entry line generated by model line '+ str(line.name)+' of model '+ str(model.name)+' is based on partner payment term!\n Please define partner on it!'))

                    payment_term_id = False
                    if model.journal_id.type in ('purchase', 'purchase_refund') and line.partner_id.property_supplier_payment_term:
                        payment_term_id = line.partner_id.property_supplier_payment_term.id
                    elif line.partner_id.property_payment_term:
                        payment_term_id = line.partner_id.property_payment_term.id
                    if payment_term_id:
                        pterm_list = pt_obj.compute(payment_term_id, value=1, date_ref=date_maturity)
                        if pterm_list:
                            pterm_list = [l[0] for l in pterm_list]
                            pterm_list.sort()
                            date_maturity = pterm_list[-1]

                vals.update({
                    'name': line.name,
                    'quantity': line.quantity,
                    'debit': line.debit,
                    'credit': line.credit,
                    'account_id': line.account_id.id,
                    'move_id': move_id.id,
                    'partner_id': line.partner_id.id,
                    'date': context.get('date', fields.Date.context_today(self)),
                    'date_maturity': date_maturity
                })
                account_move_line_obj.create(vals)

        return move_ids

    @api.onchange('journal_id')
    def onchange_journal_id(self):
        if self.journal_id and self.journal_id.company_id:
            self.company_id = self.journal_id.company_id.id
        else:
            self.company_id = False

account_model()


class account_model_line(models.Model):
    _name = "account.model.line"
    _description = "Account Model Entries"
    _order = 'sequence'

    name = fields.Char('Name')
    sequence = fields.Integer(string='Sequence', help="The sequence field is used to order the resources from lower sequences to higher ones.")
    quantity = fields.Float(string='Quantity', digits=dp.get_precision('Account'), help="The optional quantity on entries.", default=0)
    debit = fields.Float(string='Debit', digits=dp.get_precision('Account'), default=0)
    credit = fields.Float(string='Credit', digits=dp.get_precision('Account'), default=0)
    account_id = fields.Many2one('account.account', string='Account', ondelete="cascade")
    analytic_account_id = fields.Many2one('account.analytic.account', string='Analytic Account', ondelete="cascade")
    model_id = fields.Many2one('account.model', string='Model', required=True, ondelete="cascade", index=True)
    amount_currency = fields.Float(string='Amount Currency', help="The amount expressed in an optional other currency.")
    currency_id = fields.Many2one('res.currency', string='Currency')
    partner_id = fields.Many2one('res.partner', string='Partner')
    date_maturity = fields.Selection([('today','Date of the day'), ('partner','Partner Payment Term')], string='Maturity Date', help="The maturity date of the generated entries for this model. You can choose between the creation date or the creation date of the entries plus the partner payment terms.")

    _sql_constraints = [
        ('credit_debit1', 'CHECK (credit*debit=0)',  'Wrong credit or debit value in model, they must be positive!'),
        ('credit_debit2', 'CHECK (credit+debit>=0)', 'Wrong credit or debit value in model, they must be positive!'),
    ]

account_model_line()

class account_subscrption(models.Model):
    _name = 'account.subscription'
    _inherit = ['mail.thread']
    _description = "Account Subscription"

    name = fields.Char(string='Name', track_visibility='onchange')
    ref = fields.Char(string='Reference', track_visibility='onchange')
    model_id = fields.Many2one('account.model', string='Model')
    date_start = fields.Date(string='Start Date', default=fields.Date.context_today)
    period_total = fields.Integer(string='Number of Periods', default=12, track_visibility='onchange')
    period_nbr = fields.Integer(string='Period', default=1, track_visibility='onchange')
    period_type = fields.Selection([('day', 'Day(s)'), ('month', 'Month(s)'), ('year', 'Year(s)')], string='Period Type', default='month', track_visibility='onchange')
    state = fields.Selection([('draft', 'Draft'), ('running', 'Running'), ('done', 'Done')], string='Status', required=True, readonly=True, copy=False, default='draft', track_visibility='onchange')
    lines_id = fields.One2many('account.subscription.line', 'subscription_id', string='Subscription Lines', copy=True)

    @api.multi
    def state_draft(self):
        self.write({'state': 'draft'})
        return False

    @api.multi
    def check(self):
        todone = []
        for sub in self:
            ok = True
            for line in sub.lines_id:
                if not line.move_id.id:
                    ok = False
                    break
            if ok:
                todone.append(sub.id)
        if todone:
            self.write({'state': 'done'})
        return False

    @api.multi
    def remove_line(self):
        for sub in self:
            for line in sub.lines_id:
                if not line.move_id.id:
                    line.unlink()
        self.write({'state': 'draft'})
        return False

    @api.multi
    def compute(self):
        for sub in self:
            ds = sub.date_start
            for i in range(sub.period_total):
                self.env['account.subscription.line'].create({
                    'date': ds,
                    'subscription_id': sub.id,
                })
                if sub.period_type == 'day':
                    ds = (datetime.strptime(ds, '%Y-%m-%d') + relativedelta(days=sub.period_nbr)).strftime('%Y-%m-%d')
                if sub.period_type == 'month':
                    ds = (datetime.strptime(ds, '%Y-%m-%d') + relativedelta(months=sub.period_nbr)).strftime('%Y-%m-%d')
                if sub.period_type == 'year':
                    ds = (datetime.strptime(ds, '%Y-%m-%d') + relativedelta(years=sub.period_nbr)).strftime('%Y-%m-%d')
        self.write({'state': 'running'})
        return True

account_subscrption()

class account_subscription_line(models.Model):
    _name = "account.subscription.line"
    _description = "Account Subscription Line"
    _rec_name = 'date'

    subscription_id = fields.Many2one('account.subscription', string='Subscription', index=True)
    date = fields.Date('Date')
    move_id = fields.Many2one('account.move', string='Entry')

    @api.multi
    def move_create(self):
        tocheck = {}
        all_moves = []
        for line in self:
            data = {
                'date': line.date,
            }
            for model in line.subscription_id.model_id:
                move_ids = model.generate(data)
                tocheck[line.subscription_id.id] = True
                line.write({'move_id': move_ids[0]})
                all_moves.extend(move_ids)
        if tocheck:
            self.env['account.subscription'].check(tocheck.keys())
        return all_moves

account_subscription_line()

class account_invoice(models.Model):
    _inherit = 'account.invoice'

    account_name = fields.Char(related='invoice_line_ids.account_id.name',string='Account Name',store=True,readonly=True)
    account_number = fields.Char(string='Account Number',store=True, readonly=True, copy=False)

    state = fields.Selection([
            ('draft','Draft'),
            ('proforma', 'Pro-forma'),
            ('proforma2', 'Pro-forma'),
            ('prepaid', 'Prepaid'),
            ('open', 'Open'),
            ('paid', 'Paid'),
            ('cancel', 'Cancelled'),
        ], string='Status',index=True, readonly=True, default='draft',
        track_visibility='onchange', copy=False,
        help=" * The 'Draft' status is used when a user is encoding a new and unconfirmed Invoice.\n"
             " * The 'Pro-forma' status is used when the invoice does not have an invoice number.\n"
             " * The 'Open' status is used when user creates invoice, an invoice number is generated. It stays in the open status till the user pays the invoice.\n"
             " * The 'Paid' status is set automatically when the invoice is paid. Its related journal entries may or may not be reconciled.\n"
             " * The 'Cancelled' status is used when user cancel invoice.")

    @api.multi
    def action_invoice_payment(self):
        name = 'Supplier Prepayment Schedule'
        if self.type == 'out_invoice':
            name = 'Customer Prepayment Schedule'
        return {
            'name': name,
            'type': 'ir.actions.act_window',
            'res_model': 'prepayment.schedule',
            'view_type': 'form',
            'view_mode': 'form',
            'target': 'new',
        }

    @api.multi
    def convert_to_revenue(self):
        return {
            'name': _('Convert to Revenue'),
            'type': 'ir.actions.act_window',
            'res_model': 'prepayment.schedule.convert.revenue',
            'view_type': 'form',
            'view_mode': 'form',
            'target': 'new',
        }

account_invoice()

class account_payment(models.Model):
    _inherit = "account.payment"

    @api.multi
    def post(self):
        """ Create the journal items for the payment and update the payment's state to 'posted'.
            A journal entry is created containing an item in the source liquidity account (selected journal's default_debit or default_credit)
            and another in the destination reconciliable account (see _compute_destination_account_id).
            If invoice_ids is not empty, there will be one reconciliable move line per invoice to reconcile with.
            If the payment is a transfer, a second journal entry is created in the destination journal to receive money from the transfer account.
        """
        res = super(account_payment, self).post()
        for rec in self:

            # if rec.state != 'draft':
            #     raise UserError(_("Only a draft payment can be posted. Trying to post a payment in state %s.") % rec.state)
            #
            # if any(inv.state not in ['open','prepaid'] for inv in rec.invoice_ids):
            #     raise ValidationError(_("The payment cannot be processed because the invoice is not open!"))

            # Use the right sequence to set the name
            if rec.payment_type == 'transfer':
                sequence_code = 'account.payment.transfer'
            else:
                if rec.partner_type == 'customer':
                    if rec.payment_type == 'inbound':
                        sequence_code = 'account.payment.customer.invoice'
                    if rec.payment_type == 'outbound':
                        sequence_code = 'account.payment.customer.refund'
                if rec.partner_type == 'supplier':
                    if rec.payment_type == 'inbound':
                        sequence_code = 'account.payment.supplier.refund'
                    if rec.payment_type == 'outbound':
                        sequence_code = 'account.payment.supplier.invoice'
            rec.name = self.env['ir.sequence'].with_context(ir_sequence_date=rec.payment_date).next_by_code(sequence_code)
            if not rec.name and rec.payment_type != 'transfer':
                raise UserError(_("You have to define a sequence for %s in your company.") % (sequence_code,))

            # Create the journal entry
            amount = rec.amount * (rec.payment_type in ('outbound', 'transfer') and 1 or -1)
            move = rec._create_payment_entry(amount)

            # In case of a transfer, the first journal entry created debited the source liquidity account and credited
            # the transfer account. Now we debit the transfer account and credit the destination liquidity account.
            if rec.payment_type == 'transfer':
                transfer_credit_aml = move.line_ids.filtered(lambda r: r.account_id == rec.company_id.transfer_account_id)
                transfer_debit_aml = rec._create_transfer_entry(amount)
                (transfer_credit_aml + transfer_debit_aml).reconcile()

            rec.write({'state': 'posted', 'move_name': move.name})
        return res

account_payment()

class AccountMoveLine(models.Model):
    _inherit = 'account.move.line'

    @api.model
    def create(self,vals):
        if 'from_prepayment' in self._context and 'invoice' in self._context:
            object = self._context.get('from_prepayment')
            invoice = self._context.get('invoice')
            debit_account = credit_account = False
            if invoice.type == 'out_invoice':
                debit_account = object.payment_id.default_debit_account_id
            if invoice.type == 'in_invoice':
                debit_account = object.payment_id.default_credit_account_id
            credit_account = object.prepaid_account
            if vals.get('debit', 0) > 0 :
                vals.update({
                    'account_id' : debit_account.id
                })
            if vals.get('credit', 0) > 0 :
                vals.update({
                    'account_id' : credit_account.id
                })
        if 'from_customer_schedule' in self._context and 'invoice' in self._context:
            object = self._context.get('from_customer_schedule')
            invoice = self._context.get('invoice')
            invoice.state = 'open'
            debit_account = object.prepaid_account
            credit_account = object.revenue_account
            if vals.get('debit', 0) > 0 :
                vals.update({
                    'account_id' : debit_account.id
                })
            if vals.get('credit', 0) > 0 :
                vals.update({
                    'account_id' : credit_account.id
                })
        if 'from_supplier_schedule' in self._context and 'invoice' in self._context:
            object = self._context.get('from_supplier_schedule')
            invoice = self._context.get('invoice')
            invoice.state = 'open'
            debit_account = object.prepaid_account
            credit_account = object.revenue_account
            if vals.get('debit', 0) > 0 :
                vals.update({
                    'account_id' : debit_account.id
                })
            if vals.get('credit', 0) > 0 :
                vals.update({
                    'account_id' : credit_account.id
                })
        return super(AccountMoveLine, self).create(vals)