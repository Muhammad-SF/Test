# -*- coding: utf-8 -*-
from odoo import models, fields, api, _
from odoo.exceptions import UserError, ValidationError
from datetime import datetime
import time

class AccountModel(models.Model):
    _inherit = 'account.model'

    @api.multi
    def balance_asserted(self):
        if not self.ids:
            return True
        prec = self.env['decimal.precision'].precision_get('Account')

        self._cr.execute("""\
                SELECT      model_id
                FROM        account_model_line
                WHERE       model_id in %s
                GROUP BY    model_id
                HAVING      abs(sum(debit) - sum(credit)) > %s
                """, (tuple(self.ids), 10 ** (-max(5, prec))))
        if len(self._cr.fetchall()) != 0:
            raise UserError(_("Cannot create unbalanced entry!"))
        return True

    @api.model
    def create(self, vals):
        model = super(AccountModel, self.with_context(check_model_validity=False, name_model=vals.get('name'))).create(vals)
        model.balance_asserted()
        return model

    @api.multi
    def write(self, vals):
        if 'lines_id' in vals:
            res = super(AccountModel, self.with_context(check_model_validity=False)).write(vals)
            self.balance_asserted()
        else:
            res = super(AccountModel, self).write(vals)
        return res

    @api.multi
    def generate(self, data=None):
        if data is None:
            data = {}
        move_ids = []
        entry = {}
        account_move_obj = self.env['account.move']
        account_move_line_obj = self.env['account.move.line']

        context = dict(self._context or {})

        if data.get('date', False):
            context = dict(self._context)
            context.update({'date': data['date']})

        move_date = context.get('date', time.strftime('%Y-%m-%d'))

        move_date = datetime.strptime(move_date, "%Y-%m-%d")
        current_year = datetime.now().year
        move_year = datetime.strptime(str(move_date), "%Y-%m-%d %H:%M:%S").year
        if move_year == current_year:
            for model in self:
                ctx = context.copy()
                ctx.update({'company_id': model.company_id.id})
                ctx.update({'journal_id': model.journal_id.id})
                ctx['check_move_validity'] = False
                try:
                    entry['name'] = model.name % {'year': move_date.strftime('%Y'), 'month': move_date.strftime('%m'),
                                                  'date': move_date.strftime('%Y-%m')}
                except:
                    raise UserError(_('Wrong Model!'), _('You have a wrong expression "%(...)s" in your model!'))
                move = account_move_obj.create({
                    'ref': entry['name'],
                    'journal_id': model.journal_id.id,
                    'date': context.get('date', fields.Date.context_today(self))
                })
                move.post()
                move_ids.append(move.id)

                for line in model.lines_id:
                    analytic_account_id = False
                    if line.analytic_account_id:
                        if not model.journal_id.analytic_journal_id:
                            raise UserError(_('No Analytic Journal!'),
                                            _("You have to define an analytic journal on the '%s' journal!") % (
                                            model.journal_id.name,))
                        analytic_account_id = line.analytic_account_id.id
                    val = {
                        'move_id': move.id,
                        'journal_id': model.journal_id.id,
                        'analytic_account_id': analytic_account_id
                    }

                    if line.date_maturity == 'partner':
                        if not line.partner_id:
                            raise UserError(_('Error!'), _(
                                "Maturity date of entry line generated by model line '%s' of model '%s' is based on partner payment term!" \
                                "\nPlease define partner on it!") % (line.name, model.name))

                    val.update({
                        'name': line.name,
                        'quantity': line.quantity,
                        'debit': line.debit,
                        'credit': line.credit,
                        'account_id': line.account_id.id,
                        'partner_id': line.partner_id.id,
                    })
                    account_move_line_obj.with_context(ctx).create(val)
        return move_ids

AccountModel()

class AccountSubscription(models.Model):
    _inherit = 'account.subscription'

    total_invoice = fields.Float('Total Invoice')
    cumulative_paid = fields.Float('Cumulative Paid')
    remaining_amount = fields.Float('Remaining Amount')

    def _get_current_company(self):
        return self.env.user.company_id.name

AccountSubscription()

class AccountSubscriptionLine(models.Model):
    _inherit = 'account.subscription.line'

    invoice_amount = fields.Float('Invoice Amount')
    cumulative_paid = fields.Float('Cumulative Paid')
    remaining_amount = fields.Float('Remaining Amount')

    @api.multi
    def move_create(self):
        tocheck = {}
        all_moves = []
        obj_model = self.env['account.model']
        for line in self:
            data = {
                'date': line.date,
            }
            move_ids = line.subscription_id.model_id.generate(data)
            payment_id = self.env['account.payment'].search([('communication', '=', line.subscription_id.ref)], limit=1)
            model_debit = sum([model_line.debit for model_line in line.subscription_id.model_id.lines_id if model_line])
            line.subscription_id.total_invoice = model_debit * line.subscription_id.period_total
            # line.subscription_id.cumulative_paid = \
            #     payment_id.amount / line.subscription_id.period_total
            # amount = payment_id.amount / line.subscription_id.period_total
            if move_ids:
                line.move_id = move_ids[0]
                count = 0
                cumulative_amount = 0.00
                remaining_amount = 0.00
                invoice_amount = 0.00
                for subscription_line in line.subscription_id.lines_id:
                    if count == 0:
                        cumulative_amount = line.move_id.amount
                    if count > 0:
                        cumulative_amount += line.move_id.amount
                    remaining_amount = \
                        subscription_line.subscription_id.total_invoice \
                        - cumulative_amount
                    subscription_line.invoice_amount = line.move_id.amount
                    subscription_line.cumulative_paid = cumulative_amount
                    subscription_line.remaining_amount = remaining_amount
                    if subscription_line.move_id:
                        subscription_line.subscription_id.cumulative_paid =\
                            cumulative_amount
                        subscription_line.subscription_id.remaining_amount \
                            = remaining_amount
                    count += 1
                    tocheck[subscription_line.subscription_id.id] = True
                    # subscription_line.write({'invoice_amount': invoice_amount, 'cumulative_paid': cumulative_amount, 'remaining_amount': remaining_amount})
                    all_moves.extend(move_ids)
            # if move_ids:
            #     line.move_id = move_ids[0]
            #     count = 0
            #     cumulative_amount = 0.00
            #     remaining_amount = 0.00
            #     for subscription_line in line.subscription_id.lines_id:
            #         if count == 0:
            #             cumulative_amount = subscription_line.move_id.amount
            #             remaining_amount = subscription_line.subscription_id.total_invoice - subscription_line.move_id.amount
            #         if count > 0:
            #             cumulative_amount += subscription_line.move_id.amount
            #             remaining_amount -= subscription_line.move_id.amount
            #
            #         subscription_line.subscription_id.cumulative_paid = cumulative_amount
            #         subscription_line.subscription_id.remaining_amount = remaining_amount
            #         count += 1
            #
            #         tocheck[subscription_line.subscription_id.id] = True
            #         line.write({'invoice_amount': line.move_id.amount, 'cumulative_paid': cumulative_amount, 'remaining_amount': remaining_amount})
            #         all_moves.extend(move_ids)
        return all_moves

AccountSubscriptionLine()